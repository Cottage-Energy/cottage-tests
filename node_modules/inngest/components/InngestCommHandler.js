"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _RequestSignature_instances, _RequestSignature_verifySignature;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestCommHandler = void 0;
const canonicalize_1 = __importDefault(require("canonicalize"));
const debug_1 = __importDefault(require("debug"));
const hash_js_1 = require("hash.js");
const zod_1 = require("zod");
const ServerTiming_1 = require("../helpers/ServerTiming");
const consts_1 = require("../helpers/consts");
const devserver_1 = require("../helpers/devserver");
const env_1 = require("../helpers/env");
const errors_1 = require("../helpers/errors");
const functions_1 = require("../helpers/functions");
const net_1 = require("../helpers/net");
const promises_1 = require("../helpers/promises");
const stream_1 = require("../helpers/stream");
const strings_1 = require("../helpers/strings");
const types_1 = require("../types");
const version_1 = require("../version");
const InngestExecution_1 = require("./execution/InngestExecution");
/**
 * A schema for the response from Inngest when registering.
 */
const registerResSchema = zod_1.z.object({
    status: zod_1.z.number().default(200),
    skipped: zod_1.z.boolean().optional().default(false),
    modified: zod_1.z.boolean().optional().default(false),
    error: zod_1.z.string().default("Successfully registered"),
});
/**
 * `InngestCommHandler` is a class for handling incoming requests from Inngest (or
 * Inngest's tooling such as the dev server or CLI) and taking appropriate
 * action for any served functions.
 *
 * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
 * this class; the exposed `serve` function will - most commonly - create an
 * instance of `InngestCommHandler` and then return `instance.createHandler()`.
 *
 * See individual parameter details for more information, or see the
 * source code for an existing handler, e.g.
 * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import {
 *   InngestCommHandler,
 *   type ServeHandlerOptions,
 * } from "./components/InngestCommHandler";
 *
 * export const serve = (options: ServeHandlerOptions) => {
 *   const handler = new InngestCommHandler({
 *     frameworkName: "my-custom-handler",
 *     ...options,
 *     handler: (req: Request) => {
 *       return {
 *         body: () => req.json(),
 *         headers: (key) => req.headers.get(key),
 *         method: () => req.method,
 *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
 *         transformResponse: ({ body, status, headers }) => {
 *           return new Response(body, { status, headers });
 *         },
 *       };
 *     },
 *   });
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */
class InngestCommHandler {
    constructor(options) {
        var _a;
        /**
         * A private collection of functions that are being served. This map is used
         * to find and register functions when interacting with Inngest Cloud.
         */
        this.fns = {};
        this.env = (0, env_1.allProcessEnv)();
        /**
         * v2 -> v3 migration error.
         *
         * If a serve handler is passed a client as the first argument, it'll be
         * spread in to these options. We should be able to detect this by picking
         * up a unique property on the object.
         */
        if (Object.prototype.hasOwnProperty.call(options, "eventKey")) {
            throw new Error(`${consts_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
        }
        this.frameworkName = options.frameworkName;
        this.client = options.client;
        this.id = options.id || this.client.id;
        this.handler = options.handler;
        /**
         * Provide a hidden option to allow expired signatures to be accepted during
         * testing.
         */
        this.allowExpiredSignatures = Boolean(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params
        (_a = arguments["0"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);
        // Ensure we filter any undefined functions in case of missing imports.
        this.rawFns = options.functions.filter(Boolean);
        if (this.rawFns.length !== options.functions.length) {
            // TODO PrettyError
            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        }
        this.fns = this.rawFns.reduce((acc, fn) => {
            const configs = fn["getConfig"](new URL("https://example.com"), this.id);
            const fns = configs.reduce((acc, { id }, index) => {
                return Object.assign(Object.assign({}, acc), { [id]: { fn, onFailure: Boolean(index) } });
            }, {});
            configs.forEach(({ id }) => {
                if (acc[id]) {
                    // TODO PrettyError
                    throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
                }
            });
            return Object.assign(Object.assign({}, acc), fns);
        }, {});
        this.inngestRegisterUrl = new URL("/fn/register", options.baseUrl ||
            this.env[consts_1.envKeys.InngestApiBaseUrl] ||
            this.env[consts_1.envKeys.InngestBaseUrl] ||
            this.client["apiBaseUrl"] ||
            consts_1.defaultInngestApiBaseUrl);
        this.signingKey = options.signingKey;
        this.signingKeyFallback = options.signingKeyFallback;
        this.serveHost = options.serveHost || this.env[consts_1.envKeys.InngestServeHost];
        this.servePath = options.servePath || this.env[consts_1.envKeys.InngestServePath];
        const defaultLogLevel = "info";
        this.logLevel = zod_1.z
            .enum(types_1.logLevels)
            .default(defaultLogLevel)
            .catch((ctx) => {
            this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
            return defaultLogLevel;
        })
            .parse(options.logLevel || this.env[consts_1.envKeys.InngestLogLevel]);
        if (this.logLevel === "debug") {
            debug_1.default.enable(`${consts_1.debugPrefix}:*`);
        }
        const defaultStreamingOption = false;
        this.streaming = zod_1.z
            .union([zod_1.z.enum(["allow", "force"]), zod_1.z.literal(false)])
            .default(defaultStreamingOption)
            .catch((ctx) => {
            this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
            return defaultStreamingOption;
        })
            .parse(options.streaming || this.env[consts_1.envKeys.InngestStreaming]);
        this.fetch = (0, env_1.getFetch)(options.fetch || this.client["fetch"]);
    }
    // hashedSigningKey creates a sha256 checksum of the signing key with the
    // same signing key prefix.
    get hashedSigningKey() {
        return (0, strings_1.hashSigningKey)(this.signingKey);
    }
    get hashedSigningKeyFallback() {
        return (0, strings_1.hashSigningKey)(this.signingKeyFallback);
    }
    /**
     * `createHandler` should be used to return a type-equivalent version of the
     * `handler` specified during instantiation.
     *
     * @example
     * ```
     * // my-custom-handler.ts
     * import {
     *   InngestCommHandler,
     *   type ServeHandlerOptions,
     * } from "./components/InngestCommHandler";
     *
     * export const serve = (options: ServeHandlerOptions) => {
     *   const handler = new InngestCommHandler({
     *     frameworkName: "my-custom-handler",
     *     ...options,
     *     handler: (req: Request) => {
     *       return {
     *         body: () => req.json(),
     *         headers: (key) => req.headers.get(key),
     *         method: () => req.method,
     *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
     *         transformResponse: ({ body, status, headers }) => {
     *           return new Response(body, { status, headers });
     *         },
     *       };
     *     },
     *   });
     *
     *   return handler.createHandler();
     * };
     * ```
     */
    createHandler() {
        const handler = async (...args) => {
            var _a;
            const timer = new ServerTiming_1.ServerTiming();
            /**
             * We purposefully `await` the handler, as it could be either sync or
             * async.
             */
            const rawActions = await timer
                .wrap("handler", () => this.handler(...args))
                .catch((0, errors_1.rethrowError)("Serve handler failed to run"));
            /**
             * Map over every `action` in `rawActions` and create a new `actions`
             * object where each function is safely promisified with each access
             * requiring a reason.
             *
             * This helps us provide high quality errors about what's going wrong for
             * each access without having to wrap every access in a try/catch.
             */
            const actions = Object.entries(rawActions).reduce((acc, [key, value]) => {
                if (typeof value !== "function") {
                    return acc;
                }
                return Object.assign(Object.assign({}, acc), { [key]: (reason, ...args) => {
                        const errMessage = [
                            `Failed calling \`${key}\` from serve handler`,
                            reason,
                        ]
                            .filter(Boolean)
                            .join(" when ");
                        const fn = () => value(...args);
                        return (0, promises_1.runAsPromise)(fn)
                            .catch((0, errors_1.rethrowError)(errMessage))
                            .catch((err) => {
                            this.log("error", err);
                            throw err;
                        });
                    } });
            }, {});
            const [env, expectedServerKind] = await Promise.all([
                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, "starting to handle request"),
                actions.headers("checking expected server kind", consts_1.headerKeys.InngestServerKind),
            ]);
            this.env = env !== null && env !== void 0 ? env : (0, env_1.allProcessEnv)();
            const getInngestHeaders = () => (0, env_1.inngestHeaders)({
                env: this.env,
                framework: this.frameworkName,
                client: this.client,
                expectedServerKind: expectedServerKind || undefined,
                extras: {
                    "Server-Timing": timer.getHeader(),
                },
            });
            const actionRes = timer.wrap("action", () => this.handleAction({ actions, timer, getInngestHeaders, reqArgs: args }));
            /**
             * Prepares an action response by merging returned data to provide
             * trailing information such as `Server-Timing` headers.
             *
             * It should always prioritize the headers returned by the action, as
             * they may contain important information such as `Content-Type`.
             */
            const prepareActionRes = (res) => {
                var _a;
                return (Object.assign(Object.assign({}, res), { headers: Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), res.headers), (res.version === null
                        ? {}
                        : {
                            [consts_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_1.PREFERRED_EXECUTION_VERSION).toString(),
                        })) }));
            };
            const wantToStream = this.streaming === "force" ||
                (this.streaming === "allow" &&
                    (0, env_1.platformSupportsStreaming)(this.frameworkName, this.env));
            if (wantToStream && actions.transformStreamingResponse) {
                const method = await actions.method("starting streaming response");
                if (method === "POST") {
                    const { stream, finalize } = await (0, stream_1.createStream)();
                    /**
                     * Errors are handled by `handleAction` here to ensure that an
                     * appropriate response is always given.
                     */
                    void actionRes.then((res) => {
                        return finalize(prepareActionRes(res));
                    });
                    return timer.wrap("res", () => {
                        var _a;
                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, "starting streaming response", {
                            status: 201,
                            headers: getInngestHeaders(),
                            body: stream,
                            version: null,
                        });
                    });
                }
            }
            return timer.wrap("res", async () => {
                return actionRes.then(prepareActionRes).then((actionRes) => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return actions.transformResponse("sending back response", actionRes);
                });
            });
        };
        /**
         * Some platforms check (at runtime) the length of the function being used
         * to handle an endpoint. If this is a variadic function, it will fail
         * that check.
         *
         * Therefore, we expect the arguments accepted to be the same length as
         * the `handler` function passed internally.
         *
         * We also set a name to avoid a common useless name in tracing such as
         * `"anonymous"` or `"bound function"`.
         *
         * https://github.com/getsentry/sentry-javascript/issues/3284
         */
        Object.defineProperties(handler, {
            name: {
                value: "InngestHandler",
            },
            length: {
                value: this.handler.length,
            },
        });
        return handler;
    }
    /**
     * Given a set of functions to check if an action is available from the
     * instance's handler, enact any action that is found.
     *
     * This method can fetch varying payloads of data, but ultimately is the place
     * where _decisions_ are made regarding functionality.
     *
     * For example, if we find that we should be viewing the UI, this function
     * will decide whether the UI should be visible based on the payload it has
     * found (e.g. env vars, options, etc).
     */
    async handleAction({ actions, timer, getInngestHeaders, reqArgs, }) {
        var _a;
        const assumedMode = (0, env_1.getMode)({ env: this.env, client: this.client });
        if (assumedMode.isExplicit) {
            this._mode = assumedMode;
        }
        else {
            const serveIsProd = await ((_a = actions.isProduction) === null || _a === void 0 ? void 0 : _a.call(actions, "starting to handle request"));
            if (typeof serveIsProd === "boolean") {
                this._mode = new env_1.Mode({
                    type: serveIsProd ? "cloud" : "dev",
                    isExplicit: false,
                });
            }
            else {
                this._mode = assumedMode;
            }
        }
        this.upsertKeysFromEnv();
        try {
            const url = await actions.url("starting to handle request");
            const method = await actions.method("starting to handle request");
            const getQuerystring = async (reason, key) => {
                var _a;
                const ret = (await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url))) ||
                    url.searchParams.get(key) ||
                    undefined;
                return ret;
            };
            if (method === "POST") {
                const signature = await actions.headers("checking signature for run request", consts_1.headerKeys.Signature);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const body = await actions.body("processing run request");
                this.validateSignature(signature !== null && signature !== void 0 ? signature : undefined, body);
                const fnId = await getQuerystring("processing run request", consts_1.queryKeys.FnId);
                if (!fnId) {
                    // TODO PrettyError
                    throw new Error("No function ID found in request");
                }
                const stepId = (await getQuerystring("processing run request", consts_1.queryKeys.StepId)) ||
                    null;
                const headersToFetch = [consts_1.headerKeys.TraceParent, consts_1.headerKeys.TraceState];
                const headerPromises = headersToFetch.map(async (header) => {
                    const value = await actions.headers(`fetching ${header} for forwarding`, header);
                    return { header, value };
                });
                const fetchedHeaders = await Promise.all(headerPromises);
                const headersToForward = fetchedHeaders.reduce((acc, { header, value }) => {
                    if (value) {
                        acc[header] = value;
                    }
                    return acc;
                }, {});
                const { version, result } = this.runStep({
                    functionId: fnId,
                    data: body,
                    stepId,
                    timer,
                    reqArgs,
                    headers: headersToForward,
                });
                const stepOutput = await result;
                /**
                 * Functions can return `undefined`, but we'll always convert this to
                 * `null`, as this is appropriately serializable by JSON.
                 */
                const opDataUndefinedToNull = (op) => {
                    op.data = (0, functions_1.undefinedToNull)(op.data);
                    return op;
                };
                const resultHandlers = {
                    "function-rejected": (result) => {
                        return {
                            status: result.retriable ? 500 : 400,
                            headers: Object.assign(Object.assign(Object.assign({ "Content-Type": "application/json" }, headersToForward), { [consts_1.headerKeys.NoRetry]: result.retriable ? "false" : "true" }), (typeof result.retriable === "string"
                                ? { [consts_1.headerKeys.RetryAfter]: result.retriable }
                                : {})),
                            body: (0, strings_1.stringify)((0, functions_1.undefinedToNull)(result.error)),
                            version,
                        };
                    },
                    "function-resolved": (result) => {
                        return {
                            status: 200,
                            headers: Object.assign({ "Content-Type": "application/json" }, headersToForward),
                            body: (0, strings_1.stringify)((0, functions_1.undefinedToNull)(result.data)),
                            version,
                        };
                    },
                    "step-not-found": (result) => {
                        return {
                            status: 500,
                            headers: Object.assign(Object.assign({ "Content-Type": "application/json" }, headersToForward), { [consts_1.headerKeys.NoRetry]: "false" }),
                            body: (0, strings_1.stringify)({
                                error: `Could not find step "${result.step.displayName || result.step.id}" to run; timed out`,
                            }),
                            version,
                        };
                    },
                    "step-ran": (result) => {
                        const step = opDataUndefinedToNull(result.step);
                        return {
                            status: 206,
                            headers: Object.assign(Object.assign({ "Content-Type": "application/json" }, headersToForward), (typeof result.retriable !== "undefined"
                                ? Object.assign({ [consts_1.headerKeys.NoRetry]: result.retriable ? "false" : "true" }, (typeof result.retriable === "string"
                                    ? { [consts_1.headerKeys.RetryAfter]: result.retriable }
                                    : {})) : {})),
                            body: (0, strings_1.stringify)([step]),
                            version,
                        };
                    },
                    "steps-found": (result) => {
                        const steps = result.steps.map(opDataUndefinedToNull);
                        return {
                            status: 206,
                            headers: Object.assign({ "Content-Type": "application/json" }, headersToForward),
                            body: (0, strings_1.stringify)(steps),
                            version,
                        };
                    },
                };
                const handler = resultHandlers[stepOutput.type];
                try {
                    return await handler(stepOutput);
                }
                catch (err) {
                    this.log("error", "Error handling execution result", err);
                    throw err;
                }
            }
            if (method === "GET") {
                const registerBody = this.registerBody({
                    url: this.reqUrl(url),
                    deployId: null,
                });
                const signature = await actions.headers("checking signature for run request", consts_1.headerKeys.Signature);
                let introspection = {
                    extra: {
                        is_mode_explicit: this._mode.isExplicit,
                        message: "Inngest endpoint configured correctly.",
                    },
                    has_event_key: this.client["eventKeySet"](),
                    has_signing_key: Boolean(this.signingKey),
                    function_count: registerBody.functions.length,
                    mode: this._mode.type,
                };
                // Only allow secure introspection in Cloud mode, since Dev mode skips
                // signature validation
                if (this._mode.type === "cloud") {
                    try {
                        this.validateSignature(signature !== null && signature !== void 0 ? signature : undefined, "");
                        introspection = Object.assign(Object.assign({}, introspection), { signing_key_fallback_hash: this.hashedSigningKeyFallback, signing_key_hash: this.hashedSigningKey });
                    }
                    catch (_b) {
                        // Swallow signature validation error since we'll just return the
                        // insecure introspection
                    }
                }
                return {
                    status: 200,
                    body: (0, strings_1.stringify)(introspection),
                    headers: {
                        "Content-Type": "application/json",
                    },
                    version: undefined,
                };
            }
            if (method === "PUT") {
                let deployId = await getQuerystring("processing deployment request", consts_1.queryKeys.DeployId);
                if (deployId === "undefined") {
                    deployId = undefined;
                }
                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);
                return {
                    status,
                    body: (0, strings_1.stringify)({ message, modified }),
                    headers: {
                        "Content-Type": "application/json",
                    },
                    version: undefined,
                };
            }
        }
        catch (err) {
            return {
                status: 500,
                body: (0, strings_1.stringify)(Object.assign({ type: "internal" }, (0, errors_1.serializeError)(err))),
                headers: {
                    "Content-Type": "application/json",
                },
                version: undefined,
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                mode: this._mode,
            }),
            headers: {},
            version: undefined,
        };
    }
    runStep({ functionId, stepId, data, timer, reqArgs, headers, }) {
        const fn = this.fns[functionId];
        if (!fn) {
            // TODO PrettyError
            throw new Error(`Could not find function with ID "${functionId}"`);
        }
        const immediateFnData = (0, functions_1.parseFnData)(fn.fn, data);
        const { version } = immediateFnData;
        const result = (0, promises_1.runAsPromise)(async () => {
            const anyFnData = await (0, functions_1.fetchAllFnData)({
                data: immediateFnData,
                api: this.client["inngestApi"],
                version,
            });
            if (!anyFnData.ok) {
                throw new Error(anyFnData.error);
            }
            const executionStarters = ((s) => s)({
                [InngestExecution_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data]) => {
                        return Object.assign(Object.assign({}, acc), { 
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            [id]: { id, data } });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers,
                        },
                    };
                },
                [InngestExecution_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {
                        return Object.assign(Object.assign({}, acc), { [id]: result.type === "data"
                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                    { id, data: result.data }
                                : { id, error: result.error } });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers,
                        },
                    };
                },
            });
            const executionOptions = await executionStarters[anyFnData.value.version](anyFnData.value);
            return fn.fn["createExecution"](executionOptions).start();
        });
        return { version, result };
    }
    configs(url) {
        return Object.values(this.rawFns).reduce((acc, fn) => [...acc, ...fn["getConfig"](url, this.id)], []);
    }
    /**
     * Return an Inngest serve endpoint URL given a potential `path` and `host`.
     *
     * Will automatically use the `serveHost` and `servePath` if they have been
     * set when registering.
     */
    reqUrl(url) {
        let ret = new URL(url);
        const serveHost = this.serveHost || this.env[consts_1.envKeys.InngestServeHost];
        const servePath = this.servePath || this.env[consts_1.envKeys.InngestServePath];
        if (servePath) {
            ret.pathname = servePath;
        }
        if (serveHost) {
            ret = new URL(ret.pathname + ret.search, serveHost);
        }
        return ret;
    }
    registerBody({ url, deployId, }) {
        const body = {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.id,
            functions: this.configs(url),
            sdk: `js:v${version_1.version}`,
            v: "0.1",
            deployId: deployId || undefined,
        };
        return body;
    }
    async register(url, deployId, getHeaders) {
        var _a;
        const body = this.registerBody({ url, deployId });
        let res;
        // Whenever we register, we check to see if the dev server is up.  This
        // is a noop and returns false in production. Clone the URL object to avoid
        // mutating the property between requests.
        let registerURL = new URL(this.inngestRegisterUrl.href);
        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;
        if (inferredDevMode) {
            const host = (0, env_1.devServerHost)(this.env);
            const hasDevServer = await (0, devserver_1.devServerAvailable)(host, this.fetch);
            if (hasDevServer) {
                registerURL = (0, devserver_1.devServerUrl)(host, "/fn/register");
            }
        }
        else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {
            registerURL = new URL(this._mode.explicitDevUrl);
        }
        if (deployId) {
            registerURL.searchParams.set(consts_1.queryKeys.DeployId, deployId);
        }
        try {
            res = await (0, net_1.fetchWithAuthFallback)({
                authToken: this.hashedSigningKey,
                authTokenFallback: this.hashedSigningKeyFallback,
                fetch: this.fetch,
                url: registerURL.href,
                options: {
                    method: "POST",
                    body: (0, strings_1.stringify)(body),
                    headers: getHeaders(),
                    redirect: "follow",
                },
            });
        }
        catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
                modified: false,
            };
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        let data = {};
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data = await res.json();
        }
        catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
            throw err;
        }
        const { status, error, skipped, modified } = registerResSchema.parse(data);
        // The dev server polls this endpoint to register functions every few
        // seconds, but we only want to log that we've registered functions if
        // the function definitions change.  Therefore, we compare the body sent
        // during registration with the body of the current functions and refuse
        // to register if the functions are the same.
        if (!skipped) {
            this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        }
        return { status, message: error, modified };
    }
    /**
     * Given an environment, upsert any missing keys. This is useful in
     * situations where environment variables are passed directly to handlers or
     * are otherwise difficult to access during initialization.
     */
    upsertKeysFromEnv() {
        if (this.env[consts_1.envKeys.InngestSigningKey]) {
            if (!this.signingKey) {
                this.signingKey = String(this.env[consts_1.envKeys.InngestSigningKey]);
            }
            this.client["inngestApi"].setSigningKey(this.signingKey);
        }
        if (this.env[consts_1.envKeys.InngestSigningKeyFallback]) {
            if (!this.signingKeyFallback) {
                this.signingKeyFallback = String(this.env[consts_1.envKeys.InngestSigningKeyFallback]);
            }
            this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
        }
        if (!this.client["eventKeySet"]() && this.env[consts_1.envKeys.InngestEventKey]) {
            this.client.setEventKey(String(this.env[consts_1.envKeys.InngestEventKey]));
        }
        // v2 -> v3 migration warnings
        if (this.env[consts_1.envKeys.InngestDevServerUrl]) {
            this.log("warn", `Use of ${consts_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
        }
    }
    validateSignature(sig, body) {
        // Never validate signatures outside of prod. Make sure to check the mode
        // exists here instead of using nullish coalescing to confirm that the check
        // has been completed.
        if (this._mode && !this._mode.isCloud) {
            return;
        }
        // If we're here, we're in production; lack of a signing key is an error.
        if (!this.signingKey) {
            // TODO PrettyError
            throw new Error(`No signing key found in client options or ${consts_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
        }
        // If we're here, we're in production; lack of a req signature is an error.
        if (!sig) {
            // TODO PrettyError
            throw new Error(`No ${consts_1.headerKeys.Signature} provided`);
        }
        // Validate the signature
        new RequestSignature(sig).verifySignature({
            body,
            allowExpiredSignatures: this.allowExpiredSignatures,
            signingKey: this.signingKey,
            signingKeyFallback: this.signingKeyFallback,
        });
    }
    signResponse() {
        return "";
    }
    /**
     * Log to stdout/stderr if the log level is set to include the given level.
     * The default log level is `"info"`.
     *
     * This is an abstraction over `console.log` and will try to use the correct
     * method for the given log level.  For example, `log("error", "foo")` will
     * call `console.error("foo")`.
     */
    log(level, ...args) {
        const logLevels = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent",
        ];
        const logLevelSetting = logLevels.indexOf(this.logLevel);
        const currentLevel = logLevels.indexOf(level);
        if (currentLevel >= logLevelSetting) {
            let logger = console.log;
            if (Object.prototype.hasOwnProperty.call(console, level)) {
                logger = console[level];
            }
            logger(`${consts_1.logPrefix} ${level} -`, ...args);
        }
    }
}
exports.InngestCommHandler = InngestCommHandler;
class RequestSignature {
    constructor(sig) {
        _RequestSignature_instances.add(this);
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) {
            // TODO PrettyError
            throw new Error(`Invalid ${consts_1.headerKeys.Signature} provided`);
        }
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) {
            return false;
        }
        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();
        return delta > 1000 * 60 * 5;
    }
    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures, }) {
        try {
            __classPrivateFieldGet(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, { body, signingKey, allowExpiredSignatures });
        }
        catch (err) {
            if (!signingKeyFallback) {
                throw err;
            }
            __classPrivateFieldGet(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, {
                body,
                signingKey: signingKeyFallback,
                allowExpiredSignatures,
            });
        }
    }
}
_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures, }) {
    if (this.hasExpired(allowExpiredSignatures)) {
        // TODO PrettyError
        throw new Error("Signature has expired");
    }
    // Calculate the HMAC of the request body ourselves.
    // We make the assumption here that a stringified body is the same as the
    // raw bytes; it may be pertinent in the future to always parse, then
    // canonicalize the body to ensure it's consistent.
    const encoded = typeof body === "string" ? body : (0, canonicalize_1.default)(body);
    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.
    const key = signingKey.replace(/signkey-\w+-/, "");
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key)
        .update(encoded)
        .update(this.timestamp)
        .digest("hex");
    if (mac !== this.signature) {
        // TODO PrettyError
        throw new Error("Invalid signature");
    }
};
//# sourceMappingURL=InngestCommHandler.js.map