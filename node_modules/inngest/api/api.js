"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestApi = void 0;
const env_1 = require("../helpers/env");
const errors_1 = require("../helpers/errors");
const net_1 = require("../helpers/net");
const strings_1 = require("../helpers/strings");
const types_1 = require("../types");
const schema_1 = require("./schema");
class InngestApi {
    constructor({ baseUrl = "https://api.inngest.com", signingKey, signingKeyFallback, fetch, }) {
        this.baseUrl = baseUrl;
        this.signingKey = signingKey;
        this.signingKeyFallback = signingKeyFallback;
        this.fetch = (0, env_1.getFetch)(fetch);
    }
    get hashedKey() {
        return (0, strings_1.hashSigningKey)(this.signingKey);
    }
    get hashedFallbackKey() {
        if (!this.signingKeyFallback) {
            return;
        }
        return (0, strings_1.hashSigningKey)(this.signingKeyFallback);
    }
    // set the signing key in case it was not instantiated previously
    setSigningKey(key) {
        if (typeof key === "string" && this.signingKey === "") {
            this.signingKey = key;
        }
    }
    setSigningKeyFallback(key) {
        if (typeof key === "string" && !this.signingKeyFallback) {
            this.signingKeyFallback = key;
        }
    }
    async getRunSteps(runId, version) {
        const url = new URL(`/v0/runs/${runId}/actions`, this.baseUrl);
        return (0, net_1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
        })
            .then(async (resp) => {
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_1.ok)(schema_1.stepsSchemas[version].parse(data));
            }
            else {
                return (0, types_1.err)(schema_1.errorSchema.parse(data));
            }
        })
            .catch((error) => {
            return (0, types_1.err)({
                error: (0, errors_1.getErrorMessage)(error, "Unknown error retrieving step data"),
                status: 500,
            });
        });
    }
    async getRunBatch(runId) {
        const url = new URL(`/v0/runs/${runId}/batch`, this.baseUrl);
        return (0, net_1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
        })
            .then(async (resp) => {
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_1.ok)(schema_1.batchSchema.parse(data));
            }
            else {
                return (0, types_1.err)(schema_1.errorSchema.parse(data));
            }
        })
            .catch((error) => {
            return (0, types_1.err)({
                error: (0, errors_1.getErrorMessage)(error, "Unknown error retrieving event batch"),
                status: 500,
            });
        });
    }
}
exports.InngestApi = InngestApi;
//# sourceMappingURL=api.js.map