"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;
/**
 * Some environments don't allow access to the global queueMicrotask(). While we
 * had assumed this was only true for those powered by earlier versions of Node
 * (<14) that we don't officially support, Vercel's Edge Functions also obscure
 * the function in dev, even though the platform it's based on (Cloudflare
 * Workers) appropriately exposes it. Even worse, production Vercel Edge
 * Functions can see the function, but it immediately blows up the function when
 * used.
 *
 * Therefore, we can fall back to a reasonable alternative of
 * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern
 * environments, but at least we can still work in these environments.
 */
const shimQueueMicrotask = (callback) => {
    void Promise.resolve().then(callback);
};
/**
 * A helper function to create a `Promise` that will never settle.
 *
 * It purposefully creates no references to `resolve` or `reject` so that the
 * returned `Promise` will remain unsettled until it falls out of scope and is
 * garbage collected.
 *
 * This should be used within transient closures to fake asynchronous action, so
 * long as it's guaranteed that they will fall out of scope.
 */
const createFrozenPromise = () => {
    return new Promise(() => undefined);
};
exports.createFrozenPromise = createFrozenPromise;
/**
 * Returns a Promise that resolves after the current event loop's microtasks
 * have finished, but before the next event loop tick.
 */
const resolveAfterPending = (count = 1000) => {
    /**
     * This uses a brute force implementation that will continue to enqueue
     * microtasks 1000 times before resolving. This is to ensure that the
     * microtask queue is drained, even if the microtask queue is being
     * manipulated by other code.
     *
     * While this still doesn't guarantee that the microtask queue is drained,
     * it's our best bet for giving other non-controlled promises a chance to
     * resolve before we continue without resorting to falling in to the next
     * tick.
     */
    return new Promise((resolve) => {
        let i = 0;
        const iterate = () => {
            shimQueueMicrotask(() => {
                if (i++ > count) {
                    return resolve();
                }
                iterate();
            });
        };
        iterate();
    });
};
exports.resolveAfterPending = resolveAfterPending;
/**
 * Creates and returns Promise that can be resolved or rejected with the
 * returned `resolve` and `reject` functions.
 *
 * Resolving or rejecting the function will return a new set of Promise control
 * functions. These can be ignored if the original Promise is all that's needed.
 */
const createDeferredPromise = () => {
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject) => {
        resolve = (value) => {
            _resolve(value);
            return (0, exports.createDeferredPromise)();
        };
        reject = (reason) => {
            _reject(reason);
            return (0, exports.createDeferredPromise)();
        };
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return { promise, resolve: resolve, reject: reject };
};
exports.createDeferredPromise = createDeferredPromise;
/**
 * Creates a Promise that will resolve after the given duration, along with
 * methods to start, clear, and reset the timeout.
 */
const createTimeoutPromise = (duration) => {
    const { promise, resolve } = (0, exports.createDeferredPromise)();
    let timeout;
    // eslint-disable-next-line prefer-const
    let ret;
    const start = () => {
        if (timeout)
            return ret;
        timeout = setTimeout(() => {
            resolve();
        }, duration);
        return ret;
    };
    const clear = () => {
        clearTimeout(timeout);
        timeout = undefined;
    };
    const reset = () => {
        clear();
        return start();
    };
    ret = Object.assign(promise, { start, clear, reset });
    return ret;
};
exports.createTimeoutPromise = createTimeoutPromise;
/**
 * Take any function and safely promisify such that both synchronous and
 * asynchronous errors are caught and returned as a rejected Promise.
 *
 * The passed `fn` can be undefined to support functions that may conditionally
 * be defined.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const runAsPromise = (fn
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return Promise.resolve().then(fn);
};
exports.runAsPromise = runAsPromise;
/**
 * Returns a Promise that resolve after the current event loop tick.
 */
const resolveNextTick = () => {
    return new Promise((resolve) => setTimeout(resolve));
};
exports.resolveNextTick = resolveNextTick;
//# sourceMappingURL=promises.js.map